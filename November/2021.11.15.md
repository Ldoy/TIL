# 아키텍쳐란 무엇인가?

아키텍쳐는 정답이 없다. 그래서 직접 경험하고 판단해야 한다. 현재 소개시켜주는 것들은 제르시의 생각에 기반 한 것 

소프트웨어 공학적으로 문제가 생기는 것들이 무엇이 있을까?

⇒ 스파게티 코드 

원인 : 게을러서, 몰라서, 일정이 빠듯해서 

→ if, switch, for while등의 코드들을 많이 상용하면 복잡해질 수 있다. 

→ 변수가 많이 사용되는 경우 

→ 클래스간 의존관계가 정리가 안됨

→ 추상화의 부재 

스파게티코드 방지하기

→ 300/20 규칙 

# 판단기준

코드를 작성하는 매 순간 판단을 해야한다. 

## 기준

1. 가치 
    1. 커뮤니케이션 : 누군가 계속 읽어야 하기 때문에 
        1. 읽고 이해시킬 수 없는 코드는 가치가 없다. 
    2. 딘순해야한다. 
    3. 유연해야한다. 
    
    주의점
    
    - 단순함은 개발자의 수준에 따라 다름
    - 유연성 확보는 단순성과 trade off
    - 미래 확장을 위해 불필요하게 복잡한 패턴을 사용하는 것 경계하기
    - 코드의 양과는 상관없다.
2. 원칙
    1. 지역적인 변화를 생각해라
        1. 코드 수정 시 함께 수정되는 부분을 최소화 하기 
        2. 로직과 데이터는 한 곳에서 유지되는 것이 유리 
        3. 데이터가 수정되면 로직이 수정 될 확률이 높음 
    2. 대칭성
        1. 코드는 대칭성을 가지면 좋다. '
        2. add,remove / init, dealloc
        3. 코드 이해 편해지고 중복 코드 줄이기 쉬움
    3. 선언적 표현
        1. 적절히 사용하면 코드의 가독성 높임 
        2. 무엇을 하느냐에 초점을 맞추어 기술해라 
    4. 변화율
        1. 한 로직을 수정할 때 같이 수정되는 경우가 있고 변화하지 않는 경우가 있음. 수정할 때 같이 수정되는 것들이 같이 있는게 좋음 
    

# SOLID

### SRP

- 대표적인 위반사례
    - ViewController
        
        ![제르시 강의 ](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b5302fe-3470-4df2-a3f8-b02aa4e6146d/Screen_Shot_2021-11-15_at_20.06.12.png)
        
        제르시 강의 
        
    - router : 뷰의 전환 관리
    - layoutmanger : 뷰의 layout 관리
    

### OCP

- 새로운 기능은 쉽게 추가하고
- 추상화된 인터페이스에 크게 의존
    - 인터페이스 선언
    - 그 인터페이스 상속
    - 추상화 된 인터페이스만 바라보도록 함
- ex
    - 타입에 대한 반복적인 분기문에서 swith사용하면 모든 분기문을 사용해야함
    - 특히 디폴트를 사용하면 버그 발생 가능성 높아짐
- 언제쓰냐
    - 분기처리가 많이 될 때
    - 타입에 새로운 멤버들이 추가될 가능성이 클 때
    - 하지만 OCP가 남용되면 복잡해짐
- 어떤 부분을 추상화 시키고 어떤 부분을 구체화 할 것인가?
    - 기본적으로 변경이 없다고 생각하고 개발 단순성을 추구해 보자
    - 변경이 발생하면
        - 왜 일어나ㅏㅆ고
        - 어떤 영향이 생겼고
        - 어떤 일이 계속 일어날 것 같은 변경인가
        
        를 생각해보고 리팩토링 하자
        
    - 만약 인터페이스의 변화가 더 자주 일어나면 구체화 위치가 잘못 된 것
- 연습
    - 처음엔 의도적으로 사용해보기
    - if, switch를 극도로 제한해 보기

### LSP

리스코프 치환 원칙

- 상속에 있어 가장 중요한 기본 원칙
- LSP가 있기 때문에 OCP가 가능하다
- 잘못된 상속
    - LSString과 NSMutableString을 별도의 클래스로 설계한다 (x)
    - NSString을 상속받은 NSMutableString을 만든다. (O)
    - 부모의 행위를 자식이 거부
        - 자식이 부모의 것을  override해서 무시하게 끔하는 흐름 등
    - 퇴화함수
        - 부모에서는 동작하는 함수를 안 만들어주는 것
- 대표적인 iOS예
    - UIVIew의 `스위치` 같은 경우 UIView 에서 사이즈를 바꾸는데 switch.size로 바꾸려고 하면 작동하지 않음
    
- LSP를 위반하면
    - 하위클래스 명시적으로 지정해서 코딩해야함
    - 부모가 자식을 알아야함
    - OCP사용 어려움
    - 코드의 복잡도를 높임
    

### ISP

인터페이스 분리 원칙

- 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야한다(클라이언트 = 제공 받는 사람, 서버가 제공하는 것을 받는 사람, 예를들어 라이브러리를 사용한다면 라이브러리제공하는 사람이 서버 그걸사용하는 사람이 클라이언트)
- 서버는 클라이언트가 필요로 하는 최소한의 인터페이스만 제공해야한다.
    - 필요하지 않는 코드는 제공하지 않아야 한다.
- 상속을 통해 사용하게 되는 경우
    - 클라이언트가 사용하지 않는 메소드의 선언을 강제하게 됨
    - 상속 받은 메소드를 퇴화시켜야함
    - 덩치가 큰 프로토콜을 상속 받으면 불필요한 메소드를 선언해야 할 가능성이 높음
- 예
    - UITableViewDataSource, UITableviewDelegate를 분리한 것
    - Equatable, Comparble등등

- `POP`
    - 이걸 제대로 하기 위해선 ISP를 제대로 이해하고 습관화 해야함
    - ISP에 따라 작게 분해된 인터페이스를 이용해 코딩하는 것이 POP
    - POP와 ISP는 같게 봐도 좋을 것 같다.
    

### DIP

의존관계역전원칙

- 코드에서 통상적으로 발견되는 특별한 문제를 발견했는데 상위수준의 모듈이 하위수준의 모듈에 의존성을 가지는 경향을 발견
- DIP의 목적
    - 모듈간의 의존관계를 끊는 방법 제시
    - 의존의 방향을 단방향으로

- 의존관계 자체를 없앨 수는 없음
    - 하지만 잘 정리하지않으면 경직성을 띔
    - 무엇이 무엇을 의존하느냐에 따라 다른 결과를 가짐
        - 상위모듈(프레임워크, 라이브러리, UIKit등등)은 하위모듈에 의존해선 안된다 등등
- 언제 사용하나
    - 서로 의존관계를 가지는 경우
    - 의존 관계는 단방향으로 흘러가는 것이 좋음
    - 의존 관계가 사이클을 만드는 경우도 동일

- 의존의 방향
    - 의존관계는 구체적인 부분에서 프로토콜바라보도록 해야한다.
    - 추상적인 것이 구체적인 것에의존하지 않아야한다.
    
    - 예시
        - UITableView
            
            cell을 만드는 것을 참조하지 않음. 그냥 보여줄 뿐. 무슨 cell인지 전혀 모름. 구체적인 부분은 delegate, datasource에게 맡김 
            
        - UIViewController가 View Life-Cycle에 대한 정책을 결정
    - 할리우드 원칙
        
        = 필요하면우리가 연락 주겠다. 
        
    
- 왜 사용?
    - 의존관계를 단 방향으로 만듬
    - 추상화된 부분의 코드는 재사용성 증가

# MVC

# MVP

컨트롤러와 거의 비슷한 느낌이 있음 

view로 사용자의입력들어옴 → 뷰는 프레젠터에게 작업 요청 → 프레젠터는 모델에 요청 → 응답 후 프레젠터에게 값을 전달 → 다시 역방향으로 전달

**⇒ 결국 양방향이 됨** 

> 프레젠터와 컨트롤러의 차이
1. 비지니스 로직만 분리했다는 차이가 있을 것 같다.
> 

- 해결하기
    - 단방향으로 바꾸자

# MVVM

MVP랑 모양이 거의 동일한데 흐름이 조금 다르다. 

- View → VM → Model에게 데이터 요청 →VM전달 →VM은 응답받은 데이터를 가공해서 저장 → 뷰는 뷰모델과의 데이터 바인딩으로 인해 자동으로 갱신
- VM은 V를 모른다가 핵심

# VIPER

VM이 거대해지는 것 해결하고자 한 것

![엔티티 = 모델 객체, ](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7bba344a-7cf7-4e53-a842-a3afb7882fe0/Screen_Shot_2021-11-15_at_20.37.52.png)

엔티티 = 모델 객체, 

- 문제점
    - 뷰가 프레젠터를 알아야한다
    - 프레젠터는 인터엑터를 알아야한다

⇒ 양 방향을 모두 알아야한다는문제가 생김

⬇️

⬇️

⬇️

# VIP

View, Ineractor, Presenter 이렇게 3가지로 만듬 

⇒ 클린아키텍쳐에 가까워서 클린스위프트는 VIP 다 라고도 말함 

![제르시 활동학습 강의 ](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e84bfeb-e075-4507-a781-2a87595b3b72/Screen_Shot_2021-11-15_at_20.41.17.png)

제르시 활동학습 강의 

- Controller에서 이벤트 발생해서 모델을 요청 → intercator (API통신만 한다고 생각하면 됨. 데이터 엑세스 후 비지니스로직 처리)→ presenter가 controller에 전달 → View에서 보여줌

![Screen Shot 2021-11-15 at 20.46.33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/949a85c2-c5c2-43d7-ba3b-506267d95e7c/Screen_Shot_2021-11-15_at_20.46.33.png)

# Custom xcode Template

을 사용해서 한꺼번에 템플릿 만들면 좋음 

# KickStarter

한번 보면 좋을 것 같다.

[https://github.com/Clean-Swift/CleanStore](https://github.com/Clean-Swift/CleanStore)
