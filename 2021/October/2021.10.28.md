# 2021.10.28.

1. í•™ìŠµê³„íš
- Stanford SwiftUI lecture4ê¹Œì§€

# Stanford SwiftUI lecture4
### ë·°ëª¨ë¸ì€ ì–´ë–»ê²Œ ë§Œë“œëŠ”ê°€?

1. ìš°ì„  Model(ë³´ì—¬ì£¼ê³ ì í•˜ëŠ” ë°ì´í„°ê°€ ìˆëŠ” ê³³ í˜¹ì€ ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ëŠ” ê³³ )ì„ ë§Œë“ ë‹¤. 
    
    ```swift
    struct Model {
    	var data: [String] // ë°ì´í„°ë¡œ ê°€ì ¸ì•¼í•˜ëŠ” íƒ€ì…ì„ ì •í•´ì¤Œ
    	.
    	.
    	.
    	init //ì´ˆê¸°í™” ì‹œì— ì–´ë–¤ dataë¥¼ ê°€ì§€ëŠ”ì§€ ì •í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤. 
    }
    ```
    
2. ë·°ì—ì„œ `Model`ì˜ ë°ì´í„°ê°€ ì“°ì´ëŠ” ê³³ì„ ì°¾ì•„ë³¸ë‹¤.
3. `ViewModel`ì´ ë¬´ì—‡ì„ ì „ë‹¬í•´ ì£¼ì–´ì•¼ í•˜ëŠ”ì§€ ìƒê°í•´ ë³¸ë‹¤. 
4. `View`ì— ì „ë‹¬í•˜ëŠ” ë°ì´í„°ì— ë§ì¶°ì„œ `ViewModel`ì„ ì‘ì„±í•œë‹¤. 

ì˜ˆë¥¼ë“¤ì–´
ì•„ë˜ì™€ ê°™ì€ Viewë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤ê³  ìƒê° í•´ ë³´ì .

![simulator_screenshot_888E22D8-FCDB-455C-AD0C-CD4962C46180.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/704cea84-ecef-41e0-9402-86865a0a470e/simulator_screenshot_888E22D8-FCDB-455C-AD0C-CD4962C46180.png)

êµ¬í˜„ ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

1. card ëª¨ì–‘ì„ ë‚˜íƒ€ë‚´ëŠ” viewë¥¼ êµ¬í˜„
2. card ë¥¼ ì—¬ëŸ¬ê°œ ê°€ì§€ëŠ” stackì„ êµ¬í˜„
3. model, viewmodelêµ¬í˜„ 

```swift
struct Model {
	private(set) var data: [String]
	
	init( ... ) {
	//
		}
}

struct ViewModel {
	static let imoji = ["ğŸ’š", "ğŸ’š", "ğŸ’œ", "ğŸ’œ", 
						"ğŸ§¡", "ğŸ§¡","ğŸ¥²", "ğŸ¥²", "ğŸ‘", "ğŸ‘"]
	//imojië°°ì—´ì„ ì´ìš©í•´ Modelì¸ìŠ¤í„´ìŠ¤í™” ì§„í–‰
	private var model = Model(...)

	var cards {
		return model.data	
	}
}

struct View: View {
	let viewModel = ViewModel()
	var body: some View {
			LazyVGrid {
				Text(viewModel.cards)
.
.
}
```

## ë·°ì˜ ë³€ê²½ë˜ëŠ” ë¶€ë¶„ì„ ì–´ë–»ê²Œ ëª¨ë¸ì— ë°˜ì˜í•˜ëŠ”ê°€

### ë·° â†’ ë·°ëª¨ë¸ â†’ ëª¨ë¸

ì‚¬ìš©ìê°€ ì¹´ë“œë¥¼ í„°ì¹˜í•˜ë©´ printê°€ ë˜ë„ë¡ í•´ë³´ì

```swift
//Model
func choose(_ card: Card) {
        print(#function)
    }

//viewModel
//MARK: -Intent
    func choose(_ card: MemoryGame<String>.Card) {
        model.choose(card)
    }

// view
CardView(card: cards).aspectRatio(2/3, contentMode: .fit)
                                    .onTapGesture {
                                        viewmodel.choose(cards)
                                    }
```


### ë¬¸ì œìƒí™©
- ì¹´ë“œë¥¼ ì„ íƒí•´ë„ ì•ˆ ë’¤ì§‘í˜
    - ì¹´ë“œë·°ì˜ ì†ì„±ì´ ë°”ë€ŒëŠ” ê²ƒì„ í™•ì¸, ì†ì„± ë°”ë€” ë•Œ ë§ˆë‹¤ ë·°ë„ ë‹¤ì‹œ ê·¸ë¦¬ê³  ìˆìŒ 
    
- ì½”ë“œ
    ```swift
    	struct MemoryGame {
    		.
    		.	
    		struct Card: Hashable {
    			        static func == (lhs: MemoryGame<CardContent>.Card, rhs: MemoryGame<CardContent>.Card) -> Bool {
    			            if lhs.id == rhs.id {
    			                return true
    			            }
    			            return false
    			        }
    			
    			        func hash(into hasher: inout Hasher) {
    			        }
    			
    			        var isFaceUp: Bool = true
    			        var isMatched: Bool = false
    			        var content: CardContent
    			        var id: Int
    			    }
    		.
    		.
    }
    
    class EmojiMemoryGame: ObservableObject {
        static let imojis = ["ğŸ’™", "ğŸ’š", "ğŸ’œ", "ğŸ§¡", "ğŸ¥²", "ğŸ‘", "ğŸ˜", "ğŸ”¥"]
        
        static private func creatMemoryGame() -> MemoryGame<String> {
            MemoryGame<String>(numberOfPairsOfCard: 5) { index in
                EmojiMemoryGame.imojis[index]
            }
        }
    
        @Published private var model = creatMemoryGame()
    
        var cards: [MemoryGame<String>.Card] {
            return model.cards
        }
        
        //MARK: -Intent
        func choose(_ card: MemoryGame<String>.Card) {
            
            model.choose(card)
        }
    }
    
    var ContentView: Body {
    	@ObservedObject var viewmodel: EmojiMemoryGame = EmojiMemoryGame()
    	.
    	.
    	ForEach(viewmodel.cards, 
    				id: \.self,
    				content: { cards in
    							  CardView(card: cards)
    									.aspectRatio(2/3, contentMode: .fit)
    									 .onTapGesture {
    														// ë·°ëª¨ë¸ì´ ë³€ê²½ë˜ê³  ìˆìŒ 
    													viewmodel.choose(cards)
    															}
    	                        }
    	                    )
    	.
    	.
    }
    ```
    

- í•´ê²°
    
    Card êµ¬ì¡°ì²´ë¥¼ Hasableì´ ì•„ë‹Œ Identifierbleì„ ì±„íƒí•˜ë„ë¡ í•¨, 
    

- Hashable ì±„íƒí–ˆë˜ ì´ìœ 
![](https://i.imgur.com/JxWt4qD.png)

- í•´ê²°
    1. ëª¨ë¸ì˜  Card êµ¬ì¡°ì²´ì— Identifierableì„ì±„íƒ 
    2. ForEachë¬¸ì˜ idíŒŒë¼ë¯¸í„°ë¥¼ ì‚­ì œ 
- ì˜¤ë¥˜ì˜ ì›ì¸ì€ ë¬´ì—‡ì´ì—ˆì„ê¹Œ?

    - ForEach
        - Data, ID, Content ì„ ê°€ì§€ëŠ” ì œë„¤ë¦­. 
        - DataëŠ” RandomAccessCollectionì´ì–´ì•¼í•œë‹¤. identifiedëœ data ëŠ” SwiftUI ê°€ ë·°ë¥¼ ë™ì ìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤. 
        - Content: ë°ì´í„°ë¥¼ ì´ìš©í•´ì„œ ì»¨í…íŠ¸ë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜ 
        - ID ëŠ” Hashable í•´ì•¼í•œë‹¤. 

        ```swift
        public struct ForEach<Data, ID, Content> 
            where Data : RandomAccessCollection, ID : Hashable {

            /// The collection of underlying identified data that SwiftUI uses to create
            /// views dynamically.
            public var data: Data

            /// A function to create content on demand using the underlying data.
            public var content: (Data.Element) -> Content
        }
        ```

ì´ ì•„ë˜ extensionì„ ë³´ë©´ FroEachë¥¼ ì‚¬ìš©í•  ë•Œ IDê°€ Dataì˜ Element ì˜ IDì´ê³  Data.Elemetnê°€ Identifiableì¼ ë•Œ ì•„ë˜ì™€ ê°™ì´ ì‚¬ìš©í•œë‹¤ê³  ë‚˜ì™€ìˆë‹¤. 

```swift
extension ForEach where ID == Data.Element.ID, Content : View, Data.Element : Identifiable {
    public init(_ data: Data, @ViewBuilder content: @escaping (Data.Element) -> Content)
}
```

- ê²°ë¡ 
Identifier ë¥¼ ì±„íƒí•˜ë©´ Cardì˜ idì†ì„±ì„ êµ¬í˜„í•´ì•¼í•œë‹¤. ForEachì˜ ì…ì¥ì—ì„  idê°€ ìˆëŠ” ì¦‰ Identifier í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì´ Dataë¡œ ë“¤ì–´ì™”ê³  ë”°ë¼ì„œ IDëŠ” í•„ìš”í•˜ì§€ ì•Šì•˜ë˜ê²Œ ì•„ë‹ê¹Œ?


